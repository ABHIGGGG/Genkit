
# ⭐ PART 1 — First, understand the normal way (REST API)

This is what you already know.

### Without tRPC, normally:

1. Frontend calls an API using `fetch()`
2. That API runs a backend function
3. Backend talks to database
4. Backend returns JSON to frontend
5. Frontend uses that JSON

Example:

### Frontend:

```js
const res = await fetch("/api/users");
const data = await res.json();
```

### Backend:

```js
app.get("/api/users", () => {
  return db.user.findMany();
});
```

### Key point:

Your frontend **cannot directly call backend function**.
You MUST make an API route.

---

# ⭐ PART 2 — What is RPC (Remote Procedure Call)?

I’ll explain in the simplest possible way.

### RPC means:

**You call a backend function as if it is a normal JavaScript function.**

But in reality → it still makes a network request.
Just you don’t have to manually write the REST route.

### Example (imagine):

```js
const users = await backend.getUsers();
```

Behind the scenes:

* This still becomes an HTTP request to backend
* But you don’t write the API code
* tRPC writes all the boring API details for you

So **RPC is not magic**.
You are still making network calls.
Just:

* You don’t write `fetch`
* You don’t write `/api/user`
* You don’t parse JSON
* You don’t write TypeScript types manually

---

# ⭐ PART 3 — So what does tRPC do?

tRPC is basically doing **this job**:

Instead of this:

### REST:

Frontend → `/api/users`

tRPC lets you do:

### tRPC:

Frontend → `trpc.user.getUsers()`

Behind the scenes it still:

* Makes an API call
* Calls your backend function
* Accesses the database
* Returns data

But all this is auto-generated by tRPC.

### You only write **backend logic**, not API route boilerplate.

---

# ⭐ PART 4 — Why is this useful?

### Because:

* You write **less code**
* You don’t create **separate API route files**
* Types flow automatically (no need to define interfaces twice)
* Frontend knows exactly what backend returns

Think of it as:
**Your backend functions become automatically available to frontend.**

---

# ⭐ PART 5 — What is tRPC router?

Backend needs to expose functions.

Example router:

```ts
export const userRouter = router({
  getAll: publicProcedure.query(() => db.user.findMany()),
});
```

Here:

* `getAll` is a backend function
* Using `trpc.user.getAll.useQuery()` you call it on frontend

This is the whole idea.

---

# ⭐ PART 6 — Queries & Mutations (easy explanation)

### Query = getting data

(Like GET request)

```ts
trpc.user.getAll.useQuery()
```

### Mutation = changing data

(Like POST, PUT, DELETE)

```ts
trpc.user.create.useMutation()
```

This is exactly like React Query or REST, just simpler.

---

# ⭐ PART 7 — Why do people use TanStack Query with tRPC?

TanStack Query solves these things:

### What happens without caching?

Every time:

* User goes to a page
* Or component re-renders
* Or tab switches
  → You refetch data from server

This slows down UI and increases server load.

### TanStack Query does smart things:

* Caches data in memory
* Automatically refetches when stale
* Automatically shows loading states
* Automatically retries failed calls
* No need to manually manage state

### Real-life example:

If you open WhatsApp:

* You don’t “refetch” all chats every second
* Old chats are cached
* Only new ones load

TanStack Query gives this same behavior for web apps.

---

# ⭐ PART 8 — What is Suspense Query?

React Suspense allows:

* Automatic loading states
* Cleaner code

Instead of:

```js
if (isLoading) return <Loader />;
```

You wrap component with:

```jsx
<Suspense fallback={<Loader />}>
  <UserList />
</Suspense>
```

Inside component:

```js
const [users] = trpc.user.getAll.useSuspenseQuery();
```

Cleaner & modern.

---

# ⭐ PART 9 — Protected Procedure (easy)

This means:
**Only logged-in users can call this backend function.**

Example:

```ts
export const getProfile = protectedProcedure.query(({ ctx }) => {
  return ctx.db.user.findUnique({ where: { id: ctx.user.id } });
});
```

If user is NOT logged in → automatically throws 401.

Public Procedure = no login needed
Protected Procedure = login required

---

# ⭐ PART 10 — What is SuperJSON?

When backend returns a Date:
Normal JSON → converts it to string
SuperJSON → keeps it as pure Date object

It also handles:

* Map
* Set
* BigInt

Basically, it sends complex data types without breaking.

---

# ⭐ PART 11 — What is Clerk?

Clerk is JUST:

* Login / Signup system
* Authentication
* User sessions

It helps tRPC know WHO is calling the backend.

Clerk puts the user info in **ctx.user**, so protected procedures work.

---

# ⭐ PART 12 — Full request flow (VERY SIMPLE EXPLANATION)

### 1. Frontend calls:

```ts
trpc.user.getAll.useQuery();
```

### 2. This becomes an API call

(tRPC auto creates the API handler)

### 3. Backend receives it

calls your function:

```ts
db.user.findMany();
```

### 4. Response goes back through SuperJSON

### 5. TanStack Query caches it

### 6. UI gets the data instantly

---

# ⭐ FINAL SIMPLE SUMMARY (READ THIS)

### REST:

* You create URL
* You write fetch
* You write controller
* You define TypeScript manually
* You parse JSON
* No type safety frontend↔backend

### tRPC:

* You write only backend function
* tRPC auto-exposes it
* Frontend calls it like a function
* Types are automatic
* No boilerplate
* TanStack Query manages caching

### Clerk:

Handles login.

### SuperJSON:

Allows returning Dates/Maps/etc.

### RPC:

Call backend functions like normal functions.



sandbox setup

1. Packaging your Next.js environment inside Docker

Because E2B needs a predictable environment.

2. Building an E2B sandbox template from that Docker image

So the LLM / generator can spawn sandboxes on demand.

3. Making the sandbox automatically run compile_page.sh

This script:

waits for Next.js dev server to be ready

compiles the homepage

ensures the sandbox is running a live Next.js instance